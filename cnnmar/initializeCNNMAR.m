function net = initializeCNNMAR(nPatch, nMC, nKernel, nFeature, nConv)
% initializeCNNMAR Initialize a CNN for MAR
% Input:
% nPatch:       the pixel numbers along x/y direction of a patch
% nMC:          number of input methods/images
% nKernel:      size of the filter along x or y direction, must be odd and
% no less than 3
% nCov:         number of convolutional layers, no less than 2
% Output:
% net:          the initalized network


nPad = (nKernel - 1)/2;

net.meta.inputSize = [nPatch nPatch nMC 1] ;

net.layers = { } ;

net.layers{end+1} = struct(...
  'name', 'conv1', ...
  'type', 'conv', ...
  'weights', {xavier(nKernel,nKernel,nMC,nFeature)}, ...
  'pad', nPad, ...
  'learningRate', [1 1], ...
  'weightDecay', [0.00 0]) ;

net.layers{end+1} = struct(...
  'name', 'relu1', ...
  'type', 'relu') ;

for iConv = 2:nConv-1
    
    iconvName = ['conv', num2str(iConv)];
    ireluName = ['relu', num2str(iConv)];
    
    net.layers{end+1} = struct(...
        'name', iconvName, ...
        'type', 'conv', ...
        'weights', {xavier(nKernel,nKernel,nFeature,nFeature)}, ...
        'pad', nPad, ...
        'learningRate', [1 1], ...
        'weightDecay', [0.00 0]) ;
    
    net.layers{end+1} = struct(...
        'name', ireluName, ...
        'type', 'relu') ;
    
end

net.layers{end+1} = struct(...
  'name', 'prediction', ...
  'type', 'conv', ...
  'weights', {xavier(nKernel,nKernel,nFeature,1)}, ...
  'pad', nPad, ...
  'stride', 1, ...
  'learningRate', [1 1], ...
  'weightDecay', [0 0]) ;

% Consolidate the network, fixing any missing option
% in the specification above.

net = vl_simplenn_tidy(net) ;
